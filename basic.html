<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>OpenGL Tutorial for OpenTK by Xposure</title>

    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css">

    <!-- Optional theme -->
    <link rel="stylesheet" href="stylesheets/bootstrap-theme.min.css">
    <link rel="stylesheet" href="stylesheets/docs.min.css">
    <link rel="stylesheet" href="stylesheets/custom.css">

    <!--<link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">-->

    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

</head>
<body>
    <header class="navbar navbar-static-top bs-docs-nav" id="header" role="banner">
        <div class="container">
            <div class="navbar-header">
                <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a href="../" class="navbar-brand hidden-sm hidden-md hidden-lg">OpenGL Tutorials</a>
            </div>
            <nav class="collapse navbar-collapse bs-navbar-collapse">
                <ul class="nav navbar-nav">
                    <li><a href="index.html">HOME</a></li>
                    <li><a class="active" href="basic.html">BEGINNER</a></li>
                    <li><a href="intermediate.html">INTERMEDIATE</a></li>
                </ul>
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="https://github.com/xposure/opengl-tutorial-csharp">GITHUB</a></li>
                    <li><a href="https://github.com/xposure/opengl-tutorial-csharp/zipball/master">ZIP</a></li>
                    <li><a href="https://github.com/xposure/opengl-tutorial-csharp/tarball/master">TAR</a></li>
                </ul>
            </nav>
        </div>
    </header>
    <div class="container">
        <section>
            <div id="title">
                <h1 class="page-header">OpenGL Tutorials C#</h1>
                <p>OpenGL 3.3+ based on http://www.opengl-tutorial.org/</p>
                <hr>
                <span class="credits left">Project maintained by <a href="https://github.com/xposure">Xposure</a></span>
                <span class="credits right">Hosted on GitHub Pages — Theme parts by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
            </div>
        </section>
    </div>
    <div class="container bs-docs-container">
        <div class="row">
            <div class="col-md-9" role="main">
<!-- OPENING A WINDOW       -->
                <section class="bs-docs-section">
                    <h1 class="page-header">Opening a window</h1>
                    <section>
                        <h2>Introduction</h2>
                        <section>
                            <p>Welcome to the first tutorial!</p>
                            <p>Before jumping into OpenGL, you will first learn how to build the code that goes with each tutorial, how to run it, and most importantly, how to play with the code yourself.</p>
                        </section>
                        <h2>Prerequisites</h2>
                        <section>
                            <h3>OpenTK 1.1</h3>
                            <section>
                                <p>This is a wrapper for .NET to give you access to all the OpenGL commands. You can grab it from <a href="http://www.opentk.com/">here</a>.</p>
                            </section>
                            <h3>Visual Studio</h3>
                            <section>
                                <p>This series will use Visual Studio 2013 Community Edition which can be found <a href="https://www.visualstudio.com/en-us/downloads/download-visual-studio-vs.aspx">here</a>. Visual Studio 2010 or later should also work without any changes.</p>
                            </section>
                            <h3>Experience</h3>
                            <section>
                                <p>Experience with any programming language ( C, Java, Lisp, Javascript, whatever ) is better to fully understand the code, but not needed ; it will merely be more complicated to learn two things at the same time.</p>
                                <p>All tutorials are written in “C#” : Lots of effort has been made to make the code as simple as possible. No templates or classes. This way, you will be able to understand everything even if you only know Java.</p>
                            </section>
                        </section>

                        <h2>Forget Everything</h2>
                        <section>
                            <p>
                                You don’t have to know anything, but you have to forget everything you know about OpenGL. If you know about something that looks like GL.Begin(), forget it. Here you will learn modern OpenGL (OpenGL 3 and 4) , and most online tutorials teach “old” OpenGL (OpenGL 1 and 2). So forget everything you might know before your brain melts from the mix.
                            </p>
                        </section>
                        <h2>Building the tutorials</h2>
                        <section>
                            <p>All tutorials can be built on Windows <del>, Linux, and MAC</del>:</p>
                            <ol>
                                <li> Update your drivers !! doooo it. You’ve been warned.</li>
                                <li> Download visual studio express or community edition</li>
                                <li> Download the source code of the tutorials</li>
                                <li> Build the project</li>
                                <li> Play with the samples !</li>
                            </ol>
                            <h3>Windows</h3>
                            <section>
                                <p>Follow these steps if you would like to checkout the completed source code and to play with each tutorial. We will be building this repository based on the tutorials.</p>
                                <ol>
                                    <li> Updating your drivers should be easy. Just go to NVIDIA’s or AMD’s website and download the drivers. If unsure about your GPU model : Control Panel -&gt; System and Security -&gt; System -&gt; Device Manager -&gt; Display adapter. If you have an integrated Intel GPU, drivers are usually provided by your OEM (Dell, HP, …).</li>
                                    <li> We suggest using Visual Studio 2010+ Express as a compiler. You can download it for free here.</li>
                                    <li> Check out the source code, for instance in <code>C:\Users\XYZ\Projects\OpenGLTutorials\</code>.</li>
                                    <li> Open <code>C:\Users\XYZ\Projects\OpenGLTutorials\</code>. You will see a <code>OpenGLTutorials.sln</code> file : open it with Visual Studio.</li>
                                    <li> In the Build menu, click Build All. Hopefuly no error occurs.</li>
                                    <li> Set playground as the default start up project by right clicking it and selecting the option.</li>
                                    <li>
                                        <span>Press F5 to run the project</span>
                                        <div class="row">
                                            <img class="col-md-12" src="https://camo.githubusercontent.com/233e72d8b9d04ddfed692a1eeb8d0d7472e170f9/687474703a2f2f7777772e6f70656e676c2d7475746f7269616c2e6f72672f77702d636f6e74656e742f75706c6f6164732f323031312f30342f656d7074795f77696e646f772e706e67" alt="sample screen" data-canonical-src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/empty_window.png">
                                        </div>
                                        <span>You will see an empty window like this and can press escape to quit.</span>
                                    </li>
                                </ol>
                            </section>
                        </section>
                        <h2>Running the tutorials</h2>
                        <section>
                            <p>You can run the tutorials directly from the directory : simply double-click on the executable. If you like command line best, cd to the right directory.</p>
                            <p>You can also run the tutorials from the IDE by right clicking a project and selecting it as the start up project.</p>
                        </section>
                        <h2>Following along</h2>
                        <section>
                            <p>Each tutorial comes with its source code and data, which can be found in tutorialXX/. However, you will never modify these projects : they are for reference only. Open playground/playground.cpp, and tweak this file instead. Torture it in any way you like. If you are lost, simply cut’n paste any tutorial in it, and everything should be back to normal.</p>
                            <p>We will provide snippets of code all along the tutorials. Don’t hesitate to cut’n paste them directly in the playground while you’re reading : experimentation is good. Avoid simply reading the finished code, you won’t learn a lot this way. Even with simple cut’n pasting, you’ll get your boatload of problems.</p>
                        </section>
                        <h2>Starting from scratch</h2>
                        <section>
                            <ol>
                                <li> First thing you want to do is open up Visual Studio.</li>
                                <li>
                                    Next go to <code>File</code> -&gt; <code>New</code> -&gt; <code>Project</code>
                                </li>
                                <li> Select a Visual C# Console Application</li>
                                <li>
                                    For the <code>Name</code> you can put <code>T1 - Opening a window</code>
                                </li>
                                <li> For the location you can set it where ever you like, the default should be <code>c:\users\&lt;YOUR_USER&gt;\documents\visual studio 2013\Projects\</code> which is what we will use</li>
                                <li>
                                    Check <code>Create directory for solution</code>
                                </li>
                                <li>
                                    For the solution name, we will set it to <code>OpenGLTutorials</code>
                                </li>
                                <li>
                                    Last we need to add a reference to OpenTK to our project, you will have to do this every time you start a new tutorial, so remember these steps.

                                    <ol>
                                        <li>
                                            Right click <code>References</code> under <code>T1 - Opening a window</code> and select <code>Add Reference</code>
                                        </li>
                                        <li>
                                            Next you want to make sure that <code>Assemblie</code> -&gt; <code>Framework</code> is selected and in the search assemblies on the right, type <code>opentk</code>. Note: If there is more than one listed, take the latest 1.1 version, for example, mine is <code>File Version: 1.1.1664.6217</code>
                                        </li>
                                        <li>
                                            Check the correct <code>OpenTK</code> entry and click <code>OK</code>
                                        </li>
                                    </ol>
                                </li>
                                <li> You are now ready for your first tutorial</li>
                            </ol>
                        </section>
                        <h2>Opening the window</h2>
                        <section>
                            <p>Finally ! OpenGL code ! Well, not really. All tutorials show you the “low level” way to do things, so that you can see that no magic happens.</p>
                            <p>Ok, let’s go. First we need to open up <code>program.cs</code> and set the correct <code>using</code> statements, they should look like this.</p>
<pre><code>using System;
using OpenTK;
using OpenTK.Input;
using OpenTK.Graphics;
</code></pre>
                            <p>We can add this to get our first OpenGL window!</p>
                            <pre><code>using (var game = new GameWindow(1024, 768,
                       GraphicsMode.Default,          //default format
                       "Tutorial 01",                 //title in the window
                       GameWindowFlags.Default,       //default window style
                       DisplayDevice.Default,         //default monitor
                       3,3,                           //we want opengl 3.3
                       GraphicsContextFlags.Default   //default context
                       ))
{
    game.Visible = true;   //show the window
</code></pre>
                            <p>Build this and run. A window should appear, and be closed right away. Of course ! We need to wait until the user hits the Escape key :</p>
                        </section>
                        <pre><code>//variable to store the latest keyboard state
KeyboardState keyboard;
do
{
    // Draw nothing, see you in tutorial 2 !
    // Swap buffers
    game.SwapBuffers();
    game.ProcessEvents();
    //we need to poll the current keyboard state
    keyboard = OpenTK.Input.Keyboard.GetState();
}   // Check if the ESC key was pressed or the window was closed
while (!keyboard[Key.Escape]);</code></pre>
                        <p>And this concludes our first tutorial ! In Tutorial 2, you will learn how to actually draw a triangle.</p>
                        <p>Here is the final output...</p>
                        <pre><code>using System;
using OpenTK;
using OpenTK.Input;
using OpenTK.Graphics;
namespace T1___Opening_a_window
{
    class Program
    {
        static void Main(string[] args)
        {
            using (var game = new GameWindow(1024, 768,            
                               GraphicsMode.Default,          //default format
                               "Tutorial 01",                 //title in the window
                               GameWindowFlags.Default,       //default window style
                               DisplayDevice.Default,         //default monitor
                               3, 3,                          //we want opengl 3.3
                               GraphicsContextFlags.Default   //default context
                               ))
            {
                game.Visible = true;   //show the window
                //variable to store the latest keyboard state
                KeyboardState keyboard;
                do
                {
                    // Draw nothing, see you in tutorial 2 !
                    // Swap buffers
                    game.SwapBuffers();
                    game.ProcessEvents();
                    //we need to poll the current keyboard state
                    keyboard = OpenTK.Input.Keyboard.GetState();
                }   // Check if the ESC key was pressed or the window was closed
                    // Also make sure they didn't click the "X" to close the window
                while (!game.IsExiting && !keyboard[Key.Escape]);
            }
        }
    }
}</code></pre>
                    </section>
                </section>
<!--  THE FIRST TRIANGLE    -->
                <section class="bs-docs-section">
                    <h1 class="page-header">The first triangle</h1>
                    <section>
                        <p>This will be another long tutorial.</p>
                        <p>OpenGL 3 makes it easy to write complicated stuff, but at the expense that drawing a simple triangle is actually quite difficult.</p>
                        <p>Don’t forget to cut’n paste the code on a regular basis.</p>
                        <h2>The VAO</h2>
                        <section>
                            <p>I won’t dig into details now, but you need to create a Vertex Array Object and set it as the current one :</p>
                            <p class="alert alert-info">It's important to note that this vao is always bound since we never unbind it or bind a new one. This means that all the gl calls that modified a vao will modified this one.</p>
                            <pre><code>var vertexArrayID = GL.GenVertexArray();
GL.BindVertexArray(vertexArrayID);
</code></pre>
                            <p>Do this once your window is created (= after the OpenGL Context creation) and before any other OpenGL call.</p>
                            <p>If you really want to know more about VAOs, there are a few other tutorials out there, but this is not very important.</p>
                        </section>
                        <h2>Screen coordinates</h2>
                        <section>
                            <p>A triangle is defined by three points. When talking about “points” in 3D graphics, we usually use the word “vertex” ( “vertices” on the plural ). A vertex has 3 coordinates : X, Y and Z. You can think about these three coordinates in the following way :</p>
                            <ul>
                                <li>X in on your right</li>
                                <li>Y is up</li>
                                <li>Z is towards your back (yes, behind, not in front of you)</li>
                            </ul>
                            <p>But here is a better way to visualize this : use the Right Hand Rule</p>
                            <ul>
                                <li>X is your thumb</li>
                                <li>Y is your index</li>
                                <li>Z is your middle finger. If you put your thumb to the right and your index to the sky, it will point to your back, too.</li>
                            </ul>
                            <p>Having the Z in this direction is weird, so why is it so ? Short answer : because 100 years of Right Hand Rule Math will give you lots of useful tools. The only downside is an unintuitive Z.</p>
                            <p>On a side note, notice that you can move your hand freely : your X, Y and Z will be moving, too. More on this later.</p>
                            <p>So we need three 3D points in order to make a triangle ; let’s go :</p>
                            <pre><code>var g_vertex_buffer_data = new[] {
  -1.0f, -1.0f, 0.0f,
   1.0f,  -1.0f, 0.0f,
   0.0f,   1.0f, 0.0f,
};</code></pre>
                            <p>The first vertex is (-1,-1,0). This means that unless we transform it in some way, it will be displayed at (-1,-1) on the screen. What does this mean ? The screen origin is in the middle, X is on the right, as usual, and Y is up. This is what it gives on a wide screen :</p>
                            <p><img src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/screenCoordinates-300x165.png" /></p>
                            <p>This is something you can’t change, it’s built in your graphics card. So (-1,-1) is the bottom left corner of your screen. (1,-1) is the bottom right, and (0,1) is the middle top. So this triangle should take most of the screen.</p>
                        </section>
                        <h2>Drawing our triangle</h2>
                        <section>
                            <p>The next step is to give this triangle to OpenGL. We do this by creating a buffer:</p>
                            <pre><code>// This will identify our vertex buffer
// Generate 1 buffer, put the resulting identifier in vertexbuffer
var vertexBuffer = GL.GenBuffer();
                
// The following commands will talk about our 'vertexbuffer' buffer
GL.BindBuffer(BufferTarget.ArrayBuffer, vertexBuffer);

// Compute the size of the array
var vertexBufferSize = new IntPtr(sizeof(float) * g_vertex_buffer_data.Length);

// Give our vertices to OpenGL.
GL.BufferData(BufferTarget.ArrayBuffer, vertexBufferSize, g_vertex_buffer_data, 
                                BufferUsageHint.StaticDraw);
</code></pre>
                            <p>This needs to be done only once.</p>
                            <p>Now, in our main loop, where we used to draw “nothing”, we can draw our magnificent triangle :</p>
                            <pre><code>GL.EnableVertexAttribArray(0);
GL.BindBuffer(BufferTarget.ArrayBuffer, vertexBuffer);
GL.VertexAttribPointer(
    0,                             // attribute 0. No particular reason for 0, 
                                   // but must match the layout in the shader.
    3,                             // size
    VertexAttribPointerType.Float, // type
    false,                         // normalized?
    0,                             // stride
    0                              // array buffer offset
);

// draw the triangles
// Starting from vertex 0; 3 vertices total -> 1 triangle
GL.DrawArrays(PrimitiveType.Triangles, 0, 3);
GL.DisableVertexAttribArray(0);</code></pre>
                            <p>If you’re lucky, you can see the result <span class="label label-danger">(don’t panic if you don’t)</span> :</p>
                            <p><img src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/triangle_no_shader1-300x232.png" /></p>
                            <p>Now this is some boring white. Let’s see how we can improve it by painting it in red. This is done by using something called shaders.</p>
                        </section>
                        <h2>Shaders</h2>
                        <section>
                            <h3>Shader compilation</h3>
                            <section>
                                <p>In the simplest possible configuration, you will need two shaders : one called Vertex Shader, which will be executed for each vertex, and one called Fragment Shader, which will be executed for each sample. And since we use 4x antialising, we have 4 samples in each pixel.</p>
                                <p>Shaders are programmed in a language called GLSL : GL Shader Language, which is part of OpenGL. Unlike C or Java, GLSL has to be compiled at run time, which means that each and every time you launch your application, all your shaders are recompiled.</p>
                                <p>The two shaders are usually in separate files. In this example, we have <code>simple.frag</code> and <code>simple.vert</code> . The extension is irrelevant, it could be .txt or .glsl .</p>
                                <p class="alert alert-info">When creating the text files simple.vert and simple.frag in VS, remember to set their <code>Build Action: none</code> and <code>Copy to Output directory: Only if newer</code> under properties so that they exist in your output directory on build.</p>
                                <p>So here’s the code. It’s not very important to fully understand it, since you often do this only once in a program, so comments should be enough. Notice that just as buffers, shaders are not directly accessible : we just have an ID. The actual implementation is hidden inside the driver.</p>
                                <pre><code>private static int LoadShaders(string vertexPath, string fragmentPath)
{
    var vertexID = GL.CreateShader(ShaderType.VertexShader);
    var fragmentID = GL.CreateShader(ShaderType.FragmentShader);
    try
    {
        LoadShader(vertexID, vertexPath, ShaderType.VertexShader);
        LoadShader(fragmentID, fragmentPath, ShaderType.FragmentShader);
        Console.WriteLine("Linking program {0}, {1}", vertexPath, fragmentPath);
        var programID = GL.CreateProgram();
        GL.AttachShader(programID, vertexID);
        GL.AttachShader(programID, fragmentID);
        GL.LinkProgram(programID);
        var result = 0;
        GL.GetProgram(programID, GetProgramParameterName.LinkStatus, out result);
        if (result != 1)
        {
            var info = GL.GetProgramInfoLog(programID);
            Console.WriteLine("FAILED: Linking program with result: {0}, info: {1}", result, info);
        }
        return programID;
    }
    finally
    {
        GL.DeleteShader(vertexID);
        GL.DeleteShader(fragmentID);
    }
}
private static void LoadShader(int shaderID, string path, ShaderType shaderType)
{
    using (var sr = new StreamReader(path))
    {
        //var shaderID = GL.CreateShader(shaderType);
        Console.WriteLine("Compiling shader {0}:{1}", shaderType, path);
        var code = sr.ReadToEnd();
        GL.ShaderSource(shaderID, code);
        GL.CompileShader(shaderID);
        var result = 0;
        GL.GetShader(shaderID, ShaderParameter.CompileStatus, out result);
        if (result != 1)
        {
            var info = GL.GetShaderInfoLog(shaderID);
            Console.WriteLine("FAILED: Compiling shader {0}:{1} with result: {2}, info: {3}", shaderType, path, result, info);
        }
    }
</code></pre>
                            </section>
                            <h3>Our vertex shader</h3>
                            <section>
                                <p>Let’s write our vertex shader first.</p>
                                <p>The first line tells the compiler that we will use OpenGL 3′s syntax.</p>
                                <pre><code class="glsl">#version 330 core</code></pre>
                                <p>The second line declares the input data :</p>
                                <pre><code class="glsl">layout(location = 0) in vec3 vertexPosition_modelspace;</code></pre>
                                <p>Let’s explain this line in detail :</p>
                                <ul>
                                    <li><code>vec3</code> is a vector of 3 components in GLSL. It is similar (but different) to the <code>OpenTK.Vector3</code> we used to declare our triangle. The important thing is that if we use 3 components in C#, we use 3 components in GLSL too.</li>
                                    <li><code>layout(location = 0)</code> refers to the buffer we use to feed the <code>vertexPosition_modelspace</code> attribute. Each vertex can have numerous attributes : A position, one or several colours, one or several texture coordinates, lots of other things. OpenGL doesn’t know what a colour is : it just sees a vec3. So we have to tell him which buffer corresponds to which input. We do that by setting the layout to the same value as the first parameter to GL.VertexAttribPointer. The value “0″ is not important, it could be 12 (but no more than <code>GL.GetInteger(GetPName.MaxVertexAttribs);</code> ), the important thing is that it’s the same number on both sides.</li>
                                    <li><code>vertexPosition_modelspace</code> could be anything else. It will contain the position of the vertex for each run of the vertex shader.</li>
                                    <li><code>in</code> means that this is some input data. Soon we’ll see the <code>out</code> keyword.</li>
                                </ul>
                                <p>The function that is called for each vertex is called main, just as in C :</p>
                                <pre><code class="glsl">void main(){</code></pre>
                                <p>Our main function will merely set the vertex’ position to whatever was in the buffer. So if we gave (1,1), the triangle would have one of its vertices at the top right corner of the screen. We’ll see in the next tutorial how to do some more interesting computations on the input position.</p>
                                <pre><code class="glsl">    gl_Position.xyz = vertexPosition_modelspace;
    gl_Position.w = 1.0;
 }</code></pre>
                                <p><code>gl_Position</code> is one of the few built-in variables : you have to assign some value to it. Everything else is optional; we’ll see what “everything else” means in Tutorial 4.</p>
                            </section>
                            <h3>Our fragment shader</h3>
                            <section>
                                <p>For our first fragment shader, we will do something really simple : set the color of each fragment to red. (Remember, there are 4 fragment in a pixel because we use 4x AA)</p>
                                <pre><code class="glsl">#version 330 core
out vec3 color;
 
void main(){
    color = vec3(1,0,0);
}</code></pre> 
                                <p>So yeah, vec3(1,0,0) means red. This is because on computer screens, colour is represented by a Red, Green, and Blue triplet, in this order. So (1,0,0) means Full Red, no green and no blue.</p>
                            </section>
                        </section>
                        <h2>Putting it all together</h2>
                        <section>
                            <p>Before the main loop, call our LoadShaders function and set the clear color :</p>
                            <pre><code>// Create and compile our GLSL program from the shaders
var programID = LoadShaders("simple.vert", "simple.frag");

// Set the clear color
GL.ClearColor(0.0f, 0.0f, 0.4f, 0.0f)</code></pre>
                            <p>Now inside the main loop, first clear the screen. This will change the background color to dark blue because of the ClearColor(0.0f, 0.0f, 0.4f, 0.0f) call above the main loop :</p>
                            <pre><code>GL.Clear(ClearBufferMask.ColorBufferBit);</code></pre>
                            <p>and then tell OpenGL that you want to use your shader :</p>
                            <pre><code>// Use our shader
GL.UseProgram(programID);</code></pre>
                            <p>… and presto, here’s your red triangle !</p>
                            <p><img src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/red_triangle-300x231.png" /></p>
                            <p>In the next tutorial we’ll learn transformations : How to setup your camera, move your objects, etc.</p>
                        </section>
                    </section>
                </section>
<!--  MATRICES              -->
                <section class="bs-docs-section">
                    <h1 class="page-header">Matrices</h1>
                    <section>
                        <p>
                            <i>The engines don’t move the ship at all. The ship stays where it is and the engines move the universe around it.</i>
                            <br />-Futurama
                        </p>
                        <p class="label label-danger">This is the single most important tutorial of the whole set. Be sure to read it at least eight times.</p>
                        <br />
                        <br />
                        <h2>Homogeneous coordinates</h2>
                        <section>
                            <p>Until then, we only considered 3D vertices as a (x,y,z) triplet. Let’s introduce w. We will now have (x,y,z,w) vectors.</p>
                            <p>This will be more clear soon, but for now, just remember this :</p>
                            <ul>
                                <li>If w == 1, then the vector (x,y,z,1) is a position in space.</li>
                                <li>If w == 0, then the vector (x,y,z,0) is a direction.</li>
                            </ul>
                            <p>(In fact, remember this forever.)</p>
                            <p>What difference does this make ? Well, for a rotation, it doesn’t change anything. When you rotate a point or a direction, you get the same result. However, for a translation (when you move the point in a certain direction), things are different. What could mean “translate a direction” ? Not much.</p>
                            <p>Homogeneous coordinates allow us to use a single mathematical formula to deal with these two cases.</p>
                        </section>
                        <h2>Transformation matrices</h2>
                        <section>
                            <h3>An introduction to matrices</h3>
                            <section>
                                <p>Simply put, a matrix is an array of numbers with a predefined number of rows and colums. For instance, a 2×3 matrix can look like this :</p>
                                <p><img src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/2X3.png" /></p>
                                <p>In 3D graphics we will only use 4×4 matrices. They will allow us to transform our (x,y,z,w) vertices. This is done by multiplying the vertex with the matrix :</p>
                                <p><strong>Matrix x Vertex  (in this order !!) = TransformedVertex</strong></p>
                                <p><img src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/MatrixXVect-300x71.gif" /></p>
                                <p>This isn’t as scary as it looks. Put your left finger on the a, and your right finger on the x. This is ax. Move your left finger to the next number (b), and your right finger to the next number (y). You’ve got by. Once again : cz. Once again : dw. ax + by + cz + dw. You’ve got your new x ! Do the same for each line, and you’ll get your new (x,y,z,w) vector.</p>
                                <p>Now this is quite boring to compute, an we will do this often, so let’s ask the computer to do it instead.</p>
                                <p><strong>In C#, with OpenTK:</strong></p>
                                <pre><code>Matrix4 myMatrix;
Vector4 myVector;
// fill myMatrix and myVector somehow
var transformedVector = Vector4.Transform(myVector,  myMatrix);</code></pre>
                                <p><strong>In GLSL :</strong></p>
                                <pre><code class="glsl">mat4 myMatrix;
vec4 myVector;
// fill myMatrix and myVector somehow
vec4 transformedVector = myMatrix * myVector; // order is important</code></pre>
                            </section>
                            <h3>Translation matrices</h3>
                            <section>
                                <p>These are the most simple tranformation matrices to understand. A translation matrix look like this :</p>
                                <p><img src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/translationMatrix.png" /></p>
                                <p>where X,Y,Z are the values that you want to add to your position.</p>
                                <p>So if we want to translate the vector (10,10,10,1) of 10 units in the X direction, we get :</p>
                                <p><img src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/translationExamplePosition1.png" /></p>
                                <p>(do it ! doooooo it)</p>
                                <p>… and we get a (20,10,10,1) homogeneous vector ! Remember, the 1 means that it is a position, not a direction. So our transformation didn’t change the fact that we were dealing with a position, which is good.</p>
                                <p>Let’s now see what happens to a vector that represents a direction towards the -z axis : (0,0,-1,0)</p>
                                <p><img src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/translationExampleDirection1.png" /></p>
                                <p>… ie our original (0,0,-1,0) direction, which is great because as I said ealier, moving a direction does not make sense.</p>
                                <p>So, how does this translate to code ?</p>
                                <p><strong>In C#, with OpenTK:</strong></p>
                                <pre><code>Matrix4 myMatrix = Matrix4.CreateTranslation(10.0f, 0.0f, 0.0f);
Vector4 myVector = new Vector4(10.0f, 10.0f, 10.0f, 0f);
// fill myMatrix and myVector somehow
var transformedVector = Vector4.Transform(myVector,  myMatrix);</code></pre>
                                <p><strong>In GLSL :</strong> Well, in fact, you almost never do this. Most of the time, you will translte in C# to compute your matrix, send it to GLSL, and do only the multiplication :</p>
                                <pre><code class="glsl">vec4 transformedVector = myMatrix * myVector;</code></pre>
                            </section>
                            <h3>Identity matrix</h3>
                            <section>
                                <p>This one is special. It doesn’t do anything. But I mention it because it’s as important as knowing that multiplying A by 1.0 gives A.</p>
                                <p><img src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/identityExample.png" /></p>
                                <p><strong>In C#, with OpenTK:</strong></p>
                                <pre><code>var myIdentityMatrix = Matrix4.Identity;</code></pre>
                            </section>
                            <h3>Scaling matrices</h3>
                            <section>
                                <p>Scaling matrices are quite easy too :</p>
                                <p><img src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/scalingMatrix.png" /></p>
                                <p>So if you want to scale a vector (position or direction, it doesn’t matter) by 2.0 in all directions :</p>
                                <p class="row"><img class="col-md-12" src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/scalingExample.png" /></p>
                                <p>
                                    and the w still didn’t change. You may ask : what is the meaning of “scaling a direction” ? Well, often, not much, so you usually don’t do such a thing, but in some (rare) cases it can be handy.
                                    (notice that the identity matrix is only a special case of scaling matrices, with (X,Y,Z) = (1,1,1). It’s also a special case of translation matrix with (X,Y,Z)=(0,0,0), by the way)
                                </p>
                                <p><strong>In C#, with OpenTK:</strong></p>
                                <pre><code>var myScalingMatrix = Matrix4.CreateScale(2.0f, 2.0f, 2.0f);</code></pre>
                            </section>
                            <h3>Rotation matrices</h3>
                            <section>
                                <p>These are quite complicated. I’ll skip the details here, as it’s not important to know their exact layout for everyday use. <del>For more information, please have a look to the Matrices and Quaternions FAQ (popular resource, probably available in your language as well).</del></p>
                                <p><strong>In C#, with OpenTK:</strong></p>
                                <pre><code>var axis = new Vector3(??, ??, ??);
Matrix4.Rotate(axis, angle_in_degress);</code></pre>
                            </section>
                            <h3>Cumulating transformations</h3>
                            <section>
                                <p>So now we know how to rotate, translate, and scale our vectors. It would be great to combine these transformations. This is done by multiplying the matrices together, for instance :</p>
                                <pre><code>var TransformedVector = Vector4.Transform(Vector4.Transform(Vector4.Transform(
    Vector4.Transform(OriginalVector, ScaleMatrix), RotationMatrix), TranslationMatrix);</code></pre>
                                <p> <span class="label label-danger">This lines actually performs the scaling FIRST, and THEN the rotation, and THEN the translation. This is how matrix multiplication works.</span></p>
                                <p>Writing the operations in another order wouldn’t produce the same result. Try it yourself :</p>
                                <ul>
                                    <li>make one step ahead ( beware of your computer ) and turn left;</li>
                                    <li>turn left, and make one step ahead</li>
                                </ul>
                                <p>As a matter of fact, the order above is what you will usually need for game characters and other items : Scale it first if needed; then set its direction, then translate it. For instance, given a ship model (rotations have been removed for simplification) :</p>
                                <p><strong>The wrong way :</strong></p>
                                <ul>
                                    <li>You translate the ship by (10,0,0). Its center is now at 10 units of the origin.</li>
                                    <li>You scale your ship by 2. Every coordinate is multiplied by 2 relative to the origin, which is far away… So you end up with a big ship, but centered at 2*10 = 20. Which you don’t want.</li>
                                </ul>
                                <p><strong>The right way :</strong></p>
                                <ul>
                                    <li>You scale your ship by 2. You get a big ship, centered on the origin.</li>
                                    <li>You translate your ship. It’s still the same size, and at the right distance.</li>
                                </ul>
                                <p>Matrix-matrix multiplication is very similar to matrix-vector multiplication, so I’ll once again skip some details <del>and redirect you the the Matrices and Quaternions FAQ if needed. For now, we’ll simply ask the computer to do it</del> :</p>
                                <p class="alert alert-warning">NOTE: In OpenTK matrix math is reversed compared to GLSL!</p>
                                <p><strong>In C#, with OpenTK :</strong></p>
                                <pre><code>var myModelMatrix = myScalingMatrix * myRotationMatrix * myTranslationMatrix;
var myTransformedVector = Vector4.Transform(myOriginalVector, myModelMatrix);</code></pre>
                                <p><strong>In GLSL :</strong></p>
                                <pre><code class="glsl">mat4 transform = mat2 * mat1;
vec4 out_vec = transform * in_vec;</code></pre>
                            </section>
                        </section>
                        <h2>The Model, View and Projection matrices</h2>
                        <section>
                            <p><i>For the rest of this tutorial, we will suppose that we know how to draw Blender’s favourite 3d model : the monkey Suzanne.</i></p>
                            <p>The Model, View and Projection matrices are a handy tool to separate transformations cleanly. You may not use this (after all, that’s what we did in tutorials 1 and 2). But you should. This is the way everybody does, because it separates everything cleanly, as we’ll see.</p>
                            <h3>The Model matrix</h3>
                            <section>
                                <p>This model, just as our beloved red triangle, is defined by a set of vertices. The X,Y,Z coordinates of these vertices are defined relative to the object’s center : that is, if a vertex is at (0,0,0), it is at the center of the object.</p>
                                <p><img class="col-md-12" src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/model.png" /></p>
                                <p>We’d like to be able to move this model, maybe because the player controls it with the keyboard and the mouse. Easy, you just learnt do do so : translation*rotation*scale, and done. You apply this matrix to all your vertices at each frame (in GLSL, not in C#!) and everything moves. Something that doesn’t move will be at the _center of the world_.</p>
                                <p><img class="col-md-12" src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/world.png" /></p>
                                <p>Your vertices are now in World Space. <i>This is the meaning of the black arrow in the image below : We went from Model Space (all vertices defined relatively to the center of the model) to World Space (all vertices defined relatively to the center of the world).</i></p>
                                <p><img class="col-md-12" src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/model_to_world.png" /></p>
                                <p><strong>We can sum this up with the following diagram :</strong></p>
                                <p><img src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/M.png" /></p>
                            </section>
                            <h3>The View matrix</h3>
                            <section>
                                <p>Let’s quote Futurama again :</p>
                                <p><i>The engines don’t move the ship at all. The ship stays where it is and the engines move the universe around it.</i></p>
                                <p><img class="col-md-12" src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/camera.png" /></p>
                                <p>When you think about it, the same applies to cameras. It you want to view a moutain from another angle, you can either move the camera… or move the mountain. While not practical in real life, this is really simple and handy in Computer Graphics.</p>
                                <p>So initially your camera is at the origin of the World Space. In order to move the world, you simply introduce another matrix. Let’s say you want to move your camera of 3 units to the right (+X). This is equivalent to moving your whole world (meshes included) 3 units to the LEFT ! (-X). While your brain melts, let’s do it :</p>
                                <pre><code>var ViewMatrix = Matrix4.CreateTranslation(-3.0f, 0.0f, 0.0f);</code></pre>
                                <p>Again, the image below illustrates this : <i>We went from World Space (all vertices defined relatively to the center of the world, as we made so in the previous section) to Camera Space (all vertices defined relatively to the camera).</i></p>
                                <p><img class="col-md-12" src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/model_to_world_to_camera.png" /></p>
                                <p>Before your head explodes from this, enjoy OpenTK's Matrix4.LookAt function:</p>
                                <pre><code>var CameraMatrix = Matrix4.LookAt(
        cameraPosition,   // the position of your camera, in world space
        cameraTarget,     // where you want to look at, in world space
        upVector          // probably (0,1,0), but (0,-1,0) would make you
                          // looking upside-down, which can be great too
    );</code></pre>
                                <p>Here’s the compulsory diagram :</p>
                                <p><img src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/MV.png" /></p>
                                <p>This is not over yet, though.</p>
                            </section>
                            <h3>The Projection matrix</h3>
                            <section>
                                <p>We’re now in Camera Space. This means that after all theses transformations, a vertex that happens to have x==0 and y==0 should be rendered at the center of the screen. But we can’t use only the x and y coordinates to determine where an object should be put on the screen : its distance to the camera (z) counts, too ! For two vertices with similar x and y coordinates, the vertex with the biggest z coordinate will be more on the center of the screen than the other.</p>
                                <p>This is called a perspective projection :</p>
                                <p><img class="col-md-12" src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/model_to_world_to_camera_to_homogeneous.png" /></p>
                                <p>And luckily for us, a 4×4 matrix can represent this projection¹ :</p>
                                <pre><code>var projectionMatrix = Matrix4.CreatePerspectiveFieldOfView(
        FoV,        // The horizontal Field of View, in degrees : the amount of "zoom". 
                    // Think "camera lens". Usually between 90° (extra wide) and 
                    // 30° (quite zoomed in)
        4.0f / 3.0f,// Aspect Ratio. Depends on the size of your window. 
                    // Notice that 4/3 == 800/600 == 1280/960, sounds familiar ?
        0.1f,       // Near clipping plane. Keep as big as possible, 
                    // or you'll get precision issues.
        100.0f      // Far clipping plane. Keep as little as possible.
    );</code></pre>
                                <p>One last time :</p>
                                <p><i>We went from Camera Space (all vertices defined relatively to the camera) to Homogeneous Space (all vertices defined in a small cube. Everything inside the cube is onscreen).</i></p>
                                <p>And the final diagram :</p>
                                <p><img src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/MVP-235x300.png" /></p>
                                <p>Here’s another diagram so that you understand better what happens with this Projection stuff. Before projection, we’ve got our blue objects, in Camera Space, and the red shape represents the frustum of the camera : the part of the scene that the camera is actually able to see.</p>
                                <p><img class="col-md-12" src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/nondeforme.png" /></p>
                                <p>Multiplying everything by the Projection Matrix has the following effect :</p>
                                <p><img class="col-md-12" src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/homogeneous.png" /></p>
                                <p>In this image, the frustum is now a perfect cube (between -1 and 1 on all axes, it’s a little bit hard to see it), and all blue objects have been deformed in the same way. Thus, the objects that are near the camera ( = near the face of the cube that we can’t see) are big, the others are smaller. Seems like real life !</p>
                                <p>Let’s see what it looks like from the “behind” the frustum :</p>
                                <p><img src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/projected1.png" /></p>
                                <p>Here you get your image ! It’s just a little bit too square, so another mathematical transformation is applied to fit this to the actual window size :</p>
                                <p><img src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/final1.png" /></p>
                                <p>And this is the image that is actually rendered !</p>
                            </section>
                            <h3>Cumulating transformations : the ModelViewProjection matrix</h3>
                            <section>
                                <p>… Just a standard matrix multiplication as you already love them !</p>
                                <p class="alert alert-warning">NOTE: In OpenTK the matrix multiplication is backwards to GLSL!</p>
                                <pre><code>// C# : compute it
var MVPmatrix = model * view * projection;</code></pre>
                                <pre><code class="glsl">// GLSL : apply it
transformed_vertex = MVP * in_vertex;</code></pre>
                            </section>
                        </section>
                        <h2>Putting it all together</h2>
                        <p>First step : generating our MVP matrix. This must be done for each model you render.</p>
                        <p class="alert alert-warning">OpenTK uses radians instead of degrees, this is the reason for the 0.7 value.</p>
                        <pre><code>// Projection matrix : 45° Field of View , 4:3 ratio, display range : 0.1 unit <-> 100 units
var Projection = Matrix4.CreatePerspectiveFieldOfView(0.785398163f, 4.0f / 3.0f, 0.1f, 100.0f);
// Camera matrix
var View = Matrix4.LookAt(
        new Vector3(4, 3, 3), // Camera is at (4,3,3), in world space
        new Vector3(0, 0, 0), // and looks at the origin
        new Vector3(0, 1, 0), // head is up (set to 0,-1,0 to look upside-down
    );
// Model matrix : an identity matrix (model will be at the origin)
var Model = Matrix4.Identity;
// Our ModelViewProjection : multiplication of our 3 matrices
var MVP = Projection * View * Model;</code></pre>
                        <p>Second step : give it to GLSL</p>
                        <pre><code>// Get a handle for our "MVP" uniform.
// Only at initialisation time.
var MatrixID = GL.GetUniformLocation(programID, "MVP");
// Send our transformation to the currently bound shader,
// in the "MVP" uniform
// For each model you render, since the MVP will be different (at least the M part)
GL.UniformMatrix4(MatrixID, false, ref MVP);</code></pre>
                        <p>Third step : use it in GLSL to transform our vertices</p>
                        <pre><code class="glsl">#version 330 core
layout(location = 0) in vec3 vertexPosition_modelspace;
uniform mat4 MVP;
 
void main(){
 
    // Output position of the vertex, in clip space : MVP * position
    vec4 v = vec4(vertexPosition_modelspace,1); // Transform an homogeneous 4D vector, remember ?
    gl_Position = MVP * v;
}</code></pre>
                        <p>Done ! Here is the same triangle as in tutorial 2, still at the origin (0,0,0), but viewed in perspective from point (4,3,3), heads up (0,1,0), with a 45° field of view.</p>
                        <p><img src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/perspective_red_triangle-300x231.png" /></p>
                        <p>In tutorial 6 you’ll learn how to modify these values dynamically using the keyboard and the mouse to create a game-like camera, but first, we’ll learn how to give our 3D models some colour (tutorial 4) and textures (tutorial 5).</p>
                        <h2>Exercises</h2>
                        <section>
                            <ul>
                                <li>Try changing the Matrix4.CreatePerspectiveFieldOfView</li>
                                <li>Instead of using a perspective projection, use an orthographic projection (Matrix4.CreateOrthographic)</li>
                                <li>Modify ModelMatrix to translate, rotate, then scale the triangle</li>
                                <li>Do the same thing, but in different orders. What do you notice ? What is the “best” order that you would want to use for a character ?</li>
                            </ul>
                        </section>
                        <h2>Addendum</h2>
                        <section>
                            <p>1 : <i>[...]luckily for us, a 4×4 matrix can represent this projection¹ : Actually, this is not correct. A perspective transformation is not affine, and as such, can’t be represented entirely by a matrix. After beeing multiplied by the ProjectionMatrix, homogeneous coordinates are divided by their own W component. This W component happens to be -Z (because the projection matrix has been crafted this way). This way, points that are far away from the origin are divided by a big Z; their X and Y coordinates become smaller; points become more close to each other, objects seem smaller; and this is what gives the perspective.</i></p>
                        </section>
                    </section>
                </section>
<!--  A COLORED CUBE        --> 
                <section class="bs-docs-section">
                    <h1 class="page-header">A colored cube</h1>
                    <section>
                        <p>Welcome for the 4rth tutorial ! You will do the following :</p>
                        <ul>
                            <li>Draw a cube instead of the boring triangle</li>
                            <li>Add some fancy colors</li>
                            <li>Learn what the Z-Buffer is</li>
                        </ul>
                        <h2>Draw a cube</h2>
                        <section>
                            <p>A cube has six square faces. Since OpenGL only knows about triangles, we’ll have to draw 12 triangles : two for each face. We just define our vertices in the same way as we did for the triangle.</p>
                            <pre><code>// Our vertices. Tree consecutive floats give a 3D vertex; Three consecutive vertices give a triangle.
// A cube has 6 faces with 2 triangles each, so this makes 6*2=12 triangles, and 12*3 vertices
var g_vertex_buffer_data = new[] {
    -1.0f,-1.0f,-1.0f, // triangle 1 : begin
    -1.0f,-1.0f, 1.0f,
    -1.0f, 1.0f, 1.0f, // triangle 1 : end
    1.0f, 1.0f,-1.0f, // triangle 2 : begin
    -1.0f,-1.0f,-1.0f,
    -1.0f, 1.0f,-1.0f, // triangle 2 : end
    1.0f,-1.0f, 1.0f,
    -1.0f,-1.0f,-1.0f,
    1.0f,-1.0f,-1.0f,
    1.0f, 1.0f,-1.0f,
    1.0f,-1.0f,-1.0f,
    -1.0f,-1.0f,-1.0f,
    -1.0f,-1.0f,-1.0f,
    -1.0f, 1.0f, 1.0f,
    -1.0f, 1.0f,-1.0f,
    1.0f,-1.0f, 1.0f,
    -1.0f,-1.0f, 1.0f,
    -1.0f,-1.0f,-1.0f,
    -1.0f, 1.0f, 1.0f,
    -1.0f,-1.0f, 1.0f,
    1.0f,-1.0f, 1.0f,
    1.0f, 1.0f, 1.0f,
    1.0f,-1.0f,-1.0f,
    1.0f, 1.0f,-1.0f,
    1.0f,-1.0f,-1.0f,
    1.0f, 1.0f, 1.0f,
    1.0f,-1.0f, 1.0f,
    1.0f, 1.0f, 1.0f,
    1.0f, 1.0f,-1.0f,
    -1.0f, 1.0f,-1.0f,
    1.0f, 1.0f, 1.0f,
    -1.0f, 1.0f,-1.0f,
    -1.0f, 1.0f, 1.0f,
    1.0f, 1.0f, 1.0f,
    -1.0f, 1.0f, 1.0f,
    1.0f,-1.0f, 1.0f
};</code></pre>
                            <p>The OpenGL buffer is created, bound, filled and configured with the standard functions (GL.GenBuffers, GL.BindBuffer, GL.BufferData, GL.VertexAttribPointer) ; see Tutorial 2 for a quick reminder. The draw call does not change either, you just have to set the right number of vertices that must be drawn :</p>
                            <pre><code>// Draw the triangle !
GL.DrawArrays(PrimitiveType.Triangles, 0, 12 * 3); // 12*3 indices starting at 0 -> 12 triangles -> 6 squares
</code></pre>
                            <p>A few remarks on this code :</p>
                            <ul>
                                <li>For now, our 3D model is fixed : in order to change it, you have to modify the source code, recompile the application, and hope for the best. We’ll learn how to load dynamic models in tutorial 7.</li>
                                <li>Each vertex is actually written at least 3 times (search “-1.0f,-1.0f,-1.0f” in the code above). This is an awful waste of memory. We’ll learn how to deal with this in tutorial 9.</li>
                            </ul>
                            <p>You now have all the needed pieces to draw the cube in white. Make the shaders work ! go on, at least try :)</p>
                        </section>
                        <h2>Adding colors</h2>
                        <section>
                            <p>A color is, conceptually, exactly the same as a position : it’s just data. In OpenGL terms, they are “attributes”. As a matter of fact, we already used this with <code>GL.EnableVertexAttribArray()</code> and <code>GL.VertexAttribPointer()</code>. Let’s add another attribute. The code is going to be very similar.</p>
                            <p>First, declare your colors : one RGB triplet per vertex. Here I generated some randomly, so the result won’t look that good, but you can do something better, for instance by copying the vertex’s position into its own color.</p>
                            <pre><code>// One color for each vertex. They were generated randomly.
var g_color_buffer_data = new[] {
    0.583f,  0.771f,  0.014f,
    0.609f,  0.115f,  0.436f,
    0.327f,  0.483f,  0.844f,
    0.822f,  0.569f,  0.201f,
    0.435f,  0.602f,  0.223f,
    0.310f,  0.747f,  0.185f,
    0.597f,  0.770f,  0.761f,
    0.559f,  0.436f,  0.730f,
    0.359f,  0.583f,  0.152f,
    0.483f,  0.596f,  0.789f,
    0.559f,  0.861f,  0.639f,
    0.195f,  0.548f,  0.859f,
    0.014f,  0.184f,  0.576f,
    0.771f,  0.328f,  0.970f,
    0.406f,  0.615f,  0.116f,
    0.676f,  0.977f,  0.133f,
    0.971f,  0.572f,  0.833f,
    0.140f,  0.616f,  0.489f,
    0.997f,  0.513f,  0.064f,
    0.945f,  0.719f,  0.592f,
    0.543f,  0.021f,  0.978f,
    0.279f,  0.317f,  0.505f,
    0.167f,  0.620f,  0.077f,
    0.347f,  0.857f,  0.137f,
    0.055f,  0.953f,  0.042f,
    0.714f,  0.505f,  0.345f,
    0.783f,  0.290f,  0.734f,
    0.722f,  0.645f,  0.174f,
    0.302f,  0.455f,  0.848f,
    0.225f,  0.587f,  0.040f,
    0.517f,  0.713f,  0.338f,
    0.053f,  0.959f,  0.120f,
    0.393f,  0.621f,  0.362f,
    0.673f,  0.211f,  0.457f,
    0.820f,  0.883f,  0.371f,
    0.982f,  0.099f,  0.879f
};</code></pre>
                            <p>The buffer is created, bound and filled in the exact same way as the previous one :</p>
                            <pre><code>var colorBuffer = GL.GenBuffer();
GL.BindBuffer(BufferTarget.ArrayBuffer, colorBuffer);
var colorBufferSize = new IntPtr(sizeof(float) * g_color_buffer_data.Length);
GL.BufferData(BufferTarget.ArrayBuffer, colorBufferSize, g_color_buffer_data, BufferUsageHint.StaticDraw);</code></pre>
                            <p>The configuration is also identical :</p>
                            <pre><code>GL.EnableVertexAttribArray(1);
GL.BindBuffer(BufferTarget.ArrayBuffer, colorBuffer);
GL.VertexAttribPointer(
    1,                              // attribute index
    3,                              // size
    VertexAttribPointerType.Float,  // type
    false,                          // normalized?
    0,                              // stride
    0                               // offset
);</code></pre>
                            <p>Now, in the vertex shader, we have access to this additional buffer :</p>
                            <pre><code class="glsl">// Notice that the "1" here equals the "1" in glVertexAttribPointer
layout(location = 1) in vec3 vertexColor;</code></pre>
                            <p>In our case, we won’t do anything fancy with it in the vertex shader. We will simply forward it to the fragment shader :</p>
                            <pre><code class="glsl">// Output data ; will be interpolated for each fragment.
out vec3 fragmentColor;
 
void main(){
 
    [...]
 
    // The color of each vertex will be interpolated
    // to produce the color of each fragment
    fragmentColor = vertexColor;
}</code></pre>
                            <p>In the fragment shader, you declare fragmentColor again :</p>
                            <pre><code>// Interpolated values from the vertex shaders
in vec3 fragmentColor;</code></pre>
                            <p>… and copy it in the final output color :</p>
                            <pre><code class="glsl">// Ouput data
out vec3 color;
 
void main(){
    // Output color = color specified in the vertex shader,
    // interpolated between all 3 surrounding vertices
    color = fragmentColor;
}</code></pre>
                            <p>And that’s what we get :</p>
                            <p class="row"><img class="col-md-12" src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/missing_z_buffer.png" /></p>
                            <p>Urgh. Ugly. To understand what happens, here’s what happens when you draw a “far” triangle and a “near” triangle :</p>
                            <p><img src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/FarNear.png" /></p>
                            <p>Seems OK. Now draw the “far” triangle last :</p>
                            <p><img src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/NearFar.png" /></p>
                            <p>It overdraws the “near” one, even though it’s supposed to be behind it ! This is what happens with our cube: some faces are supposed to be hidden, but since they are drawn last, they are visible. Let’s call the Z-Buffer to the rescue !</p>
                            <p><i>Quick Note 1</i>: If you don’t see the problem, change your camera position to (4,3,-3)</p>
                            <p><i>Quick Note 2</i>: if “color is like position, it’s an attribute”, why do we need to declare out vec3 fragmentColor; and in vec3 fragmentColor; for the color, and not for the position ? Because the position is actually a bit special : It’s the only thing that is compulsory (or OpenGL wouldn’t know where to draw the triangle !). So in the vertex shader, gl_Position is a “built-in” variable.</p>
                        </section>
                        <h2>The Z-Buffer</h2>
                        <section>
                            <p>The solution to this problem is to store the depth (i.e. “Z”) component of each fragment in a buffer, and each and every time you want to write a fragment, you first check if you should (i.e the new fragment is closer than the previous one).</p>
                            <p>You can do this yourself, but it’s so much simpler to just ask the hardware to do it itself :</p>
                            <pre><code>// Enable depth test
GL.Enable(EnableCap.DepthTest);
// Accept fragment if it closer to the camera than the former one
GL.DepthFunc(DepthFunction.Less);</code></pre>
                            <p>You also need to clear the depth each frame, instead of only the color :</p>
                            <pre><code>// Clear the screen
GL.Clear(ClearBufferMask.DepthBufferBit | ClearBufferMask.ColorBufferBit);
</code></pre>
                            <p>And this is enough to solve all your problems.</p>
                            <p><img src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/one_color_per_vertex-300x231.png" /></p>
                        </section>
                        <h2>Exercises</h2>
                        <section>
                            <ul>
                                <li>Draw the cube AND the triangle, at different locations. You will need to generate 2 MVP matrices, to make 2 draw calls in the main loop, but only 1 shader is required.</li>
                                <li>Generate the color values yourself. Some ideas : At random, so that colors change at each run; Depending on the position of the vertex; a mix of the two; Some other creative idea :) In case you don’t know C#, here’s the syntax :</li>
                            </ul>
                            <pre><code>var g_color_buffer_data = new float[12 * 3 * 3];
for (int v = 0; v < 12*3 ; v++){
    g_color_buffer_data[3*v+0] = your red color here;
    g_color_buffer_data[3*v+1] = your green color here;
    g_color_buffer_data[3*v+2] = your blue color here;
}
</code></pre>
                            <ul>
                                <li>Once you’ve done that, make the colors change each frame. You’ll have to call GL.BufferData each frame. Make sure the appropriate buffer is bound (GL.BindBuffer) before !</li>
                            </ul>
                        </section>
                    </section>
                </section>
<!--  A TEXTURED CUBE       -->
                <section class="bs-docs-section">
                    <h1 class="page-header">A textured cube</h1>
                    <section>
                        <p>In this tutorial, you will learn :</p>
                        <ul>
                            <li>What are UV coordinates</li>
                            <li>How to load textures yourself</li>
                            <li>How to use them in OpenGL</li>
                            <li>What is filtering and mipmapping, and how to use them</li>
                            <li>How to load texture more robustly with GLFW</li>
                            <li>What is the alpha channel</li>
                        </ul>
                        <h2>About UV coordinates</h2>
                        <section>
                            <p>When texturing a mesh, you need a way to tell to OpenGL which part of the image has to be used for each triangle. This is done with UV coordinates.</p>
                            <p>Each vertex has, on top of its position, a couple of floats, U and V. These coordinates are used to access the texture, in the following way :</p>
                            <p class="row"><img class="col-md-12" src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/UVintro.png" /></p>
                            <p>Notice how the texture is distorted on the triangle.</p>
                        </section>
                        <h2>Loading .BMP images yourself</h2>
                        <section>
                            <p>Knowing the BMP file format is not crucial : plenty of libraries can do it for you. But it’s very simple and can help you understand how things work under the hood. So we’ll write a BMP file loader from scratch, so that you know how it works, <span style="text-decoration: underline;">and never use it again</span></p>
                            <p>Here is the declaration of the loading function :</p>
                            <pre><code>public static int loadBMP_custom(string filepath);</code></pre>
                            <p>so it’s used like this :</p>
                            <pre><code>var image = loadBMP_custom("my_texture.bmp");</code></pre>
                            <p>Let’s see how to read a BMP file, then.</p>
                            <p>First, we’ll need some data. These variable will be set when reading the file.</p>
                            <pre><code>// Data read from the header of the BMP file
var header = new byte[54]; // Each BMP file begins by a 54-bytes header
var dataPos = 0;     // Position in the file where the actual data begins
var width = 0;
var height = 0;
var imageSize = 0;   // = width*height*3</code></pre>
                            <p>We now have to actually open the file</p>
                            <pre><code>if (!System.IO.File.Exists(filepath))
{
    Console.WriteLine("Image [{0}] could not be found.", filepath);
    return 0;
}

var fs = new FileStream(filepath, FileMode.Open, FileAccess.Read);
</code></pre>
                            <p>The first thing in the file is a 54-bytes header. It contains information such as “Is this file really a BMP file?”, the size of the image, the number of bits per pixel, etc. So let’s read this header :</p>
                            <pre><code>try
{
    if (fs.Read(header, 0, 54) != 54)
    {
        // If not 54 bytes read : problem
        Console.WriteLine("Not a correct BMP file [{0}]", filepath);
        return 0;
    }
   
}
finally
{
    fs.Close();
    fs.Dispose();
}</code></pre>
                            <p>The header always begins by BM. As a matter of fact, here’s what you get when you open a .BMP file in a hexadecimal editor :</p>
                            <p><img src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/hexbmp.png" /></p>
                            <p>So we have to check that the two first bytes are really ‘B’ and ‘M’ :</p>
                            <pre><code>if (header[0] != 'B' || header[1] != 'M')
{
    Console.WriteLine("Not a correct BMP file [{0}]", filepath);
    return 0;
}</code></pre>
                            <p>Now we can read the size of the image, the location of the data in the file, etc :</p>
                            <pre><code>// Read ints from the byte array
dataPos = BitConverter.ToInt32(header, 0x0A);
imageSize = BitConverter.ToInt32(header, 0x22);
width = BitConverter.ToInt32(header, 0x12);
height = BitConverter.ToInt32(header, 0x16)</code></pre>
                            <p>We have to make up some info if it’s missing :</p>
                            <pre><code>// Some BMP files are misformatted, guess missing information
if (imageSize == 0) imageSize = width * height * 3; // 3 : one byte for each Red, Green and Blue component
if (dataPos == 0) dataPos = 54; // The BMP header is done that way
</code></pre>
                            <p>Now that we know the size of the image, we can allocate some memory to read the image into, and read :</p>
                            <pre><code>// Actual RGB data
var data = new byte[imageSize];

// Read the actual data from the file into the buffer
fs.Read(data, 0, imageSize);
</code></pre>
                            <p>We arrive now at the real OpenGL part. Creating textures is very similar to creating vertex buffers : Create a texture, bind it, fill it, and configure it.</p>
                            <p>In glTexImage2D, the GL_RGB indicates that we are talking about a 3-component color, and GL_BGR says how exactly it is represented in RAM. As a matter of fact, BMP does not store Red->Green->Blue but Blue->Green->Red, so we have to tell it to OpenGL.</p>
                            <pre><code>// Create one OpenGL texture
var textureID = GL.GenTexture();
// "Bind" the newly created texture : all future texture functions will modify this texture
GL.BindTexture(TextureTarget.Texture2D, textureID);
// Give the image to OpenGL
GL.TexImage2D(TextureTarget.Texture2D, 0, PixelInternalFormat.Rgb, width, height, 0, PixelFormat.Rgb, PixelType.UnsignedByte, data);
GL.TexParameterI(TextureTarget.Texture2D, TextureParameterName.TextureMagFilter, new[] { (uint)TextureMagFilter.Nearest });
GL.TexParameterI(TextureTarget.Texture2D, TextureParameterName.TextureMinFilter, new[] { (uint)TextureMinFilter.Nearest })</code></pre>
                            <p>We’ll explain those last two lines later. Meanwhile, on the C++-side, you can use your new function to load a texture :</p>
                            <pre><code>var textureID = loadBMP_custom("uvtemplate.bmp");</code></pre>
                            <div class="alert alert-warning">
                                <p>Another very important point : use power-of-two textures !</p>
                                <ul>
                                    <li>good : 128*128*, 256*256, 1024*1024, 2*2…</li>
                                    <li>bad : 127*128, 3*5, …</li>
                                    <li>okay but weird : 128*256</li>
                                </ul>
                            </p>
                        </section>
                        <h2>Using the texture in OpenGL</h2>
                        <section>
                            <p>We’ll have a look at the fragment shader first. Most of it is straightforward :</p>
                            <pre><code class="glsl">#version 330 core
// Interpolated values from the vertex shaders
in vec2 UV;
out vec3 color;
 
// Values that stay constant for the whole mesh.
uniform sampler2D myTextureSampler;
void main(){
    // Output color = color specified in the texture at the specified uv
    color = texture(myTextureSampler, UV).rgb;
}</code></pre>
                            <p>Three things :</p>
                            <ul>
                                <li>The fragment shader needs UV coordinates. Seems fair.</li>
                                <li>It also needs a “sampler2D” in order to know which texture to access (you can access several texture in the same shader)</li>
                                <li>Finally, accessing a texture is done with texture(), which gives back a (R,G,B,A) vec4. We’ll see about the A shortly.</li>
                            </ul>
                            <p>The vertex shader is simple too, you just have to pass the UVs to the fragment shader :</p>
                            <pre><code class="glsl">#version 330 core
// Input vertex data, different for all executions of this shader.
layout(location = 0) in vec3 vertexPosition_modelspace;
layout(location = 1) in vec2 vertexUV;
uniform mat4 MVP;
// Output data ; will be interpolated for each fragment.
out vec2 UV;
void main(){
 
    // Output position of the vertex, in clip space : MVP * position
    vec4 v = vec4(vertexPosition_modelspace,1); // Transform an homogeneous 4D vector, remember ?
    gl_Position = MVP * v;
	UV = vertexUV;
}</code></pre>
                            <p>Remember “layout(location = 1) in vec2 vertexUV” from Tutorial 4 ? Well, we’ll have to do the exact same thing here, but instead of giving a buffer (R,G,B) triplets, we’ll give a buffer of (U,V) pairs.</p>
                            <pre><code>//UV coordinatesfor each vertex. They were created with Blender. You'll learn shortly how to do this yourself.
var g_uv_buffer_data = new[] {
    0.000059f, 1.0f-0.000004f,
    0.000103f, 1.0f-0.336048f,
    0.335973f, 1.0f-0.335903f,
    1.000023f, 1.0f-0.000013f,
    0.667979f, 1.0f-0.335851f,
    0.999958f, 1.0f-0.336064f,
    0.667979f, 1.0f-0.335851f,
    0.336024f, 1.0f-0.671877f,
    0.667969f, 1.0f-0.671889f,
    1.000023f, 1.0f-0.000013f,
    0.668104f, 1.0f-0.000013f,
    0.667979f, 1.0f-0.335851f,
    0.000059f, 1.0f-0.000004f,
    0.335973f, 1.0f-0.335903f,
    0.336098f, 1.0f-0.000071f,
    0.667979f, 1.0f-0.335851f,
    0.335973f, 1.0f-0.335903f,
    0.336024f, 1.0f-0.671877f,
    1.000004f, 1.0f-0.671847f,
    0.999958f, 1.0f-0.336064f,
    0.667979f, 1.0f-0.335851f,
    0.668104f, 1.0f-0.000013f,
    0.335973f, 1.0f-0.335903f,
    0.667979f, 1.0f-0.335851f,
    0.335973f, 1.0f-0.335903f,
    0.668104f, 1.0f-0.000013f,
    0.336098f, 1.0f-0.000071f,
    0.000103f, 1.0f-0.336048f,
    0.000004f, 1.0f-0.671870f,
    0.336024f, 1.0f-0.671877f,
    0.000103f, 1.0f-0.336048f,
    0.336024f, 1.0f-0.671877f,
    0.335973f, 1.0f-0.335903f,
    0.667969f, 1.0f-0.671889f,
    1.000004f, 1.0f-0.671847f,
    0.667979f, 1.0f-0.335851f
}</code></pre>
                            <p>The UV coordinates above correspond to the following model :</p>
                            <p><img src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/uv_mapping_blender-300x222.png" /></p>
                            <p class="alert alert-warning">The rest is obvious. Generate the buffer, bind it, fill it, configure it, and draw the Vertex Buffer as usual. Just be careful to use 2 as the second parameter (size) of glVertexAttribPointer instead of 3.</p>
                            <p>This is the result :</p>
                            <p><img src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/nearfiltering.png" /></p>
                            <p>and a zoomed-in version :</p>
                            <p><img src="http://www.opengl-tutorial.org/wp-content/uploads/2011/04/nearfiltering_zoom.png" /></p>
                        </section>
                        <h2>What is filtering and mipmapping, and how to use them</h2>
                        <section>TO BE CONTINUED</section>
                    </section>
                </section>
<!--  KEYBOARD AND MOUSE    -->
                <!--<section class="bs-docs-section">
                    <h1 class="page-header">Keyboard and mouse</h1>
                    <section></section>
                </section>-->
<!--  MODEL LOADING         -->
                <!--<section class="bs-docs-section">
                    <h1 class="page-header">Model loading</h1>
                    <section></section>
                </section>-->
<!--  BASIC SHADING         -->
                <!--<section class="bs-docs-section">
                    <h1 class="page-header">Basic shading</h1>
                    <section></section>
                </section>-->
            </div>
            <div class="col-md-3" role="complementary">
                <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix-top">
                    <ul class="nav bs-docs-sidenav"></ul>
                    <a class="back-to-top" href="#top">
                        Back to top
                    </a>
                </nav>
            </div>
        </div>
    </div>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!-- Latest compiled and minified JavaScript -->
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>

    <link rel="stylesheet" href="stylesheets/vs.css" />
    <script src="javascripts/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    <script src="javascripts/sidebar.js"></script>

</body>
</html>